(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{291:function(n,t,e){"use strict";e.r(t);var a=e(38),s=Object(a.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构","aria-hidden":"true"}},[n._v("#")]),n._v(" 数据结构")]),n._v(" "),e("p",[n._v("数据结构决定了数据存储的空间和时间效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。")]),n._v(" "),e("p",[n._v("根据对场景需求的不同，我们设计不同的数据结构，比如：")]),n._v(" "),e("ul",[e("li",[n._v("读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取；")]),n._v(" "),e("li",[n._v("读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法。")])]),n._v(" "),e("p",[n._v("算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。")]),n._v(" "),e("p",[n._v("数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。")]),n._v(" "),e("h2",{attrs:{id:"前端常遇见的数据结构问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端常遇见的数据结构问题","aria-hidden":"true"}},[n._v("#")]),n._v(" 前端常遇见的数据结构问题")]),n._v(" "),e("p",[n._v("现在我来梳理下前端常遇见的数据结构：")]),n._v(" "),e("ul",[e("li",[n._v("简单数据结构（必须理解掌握）\n"),e("ul",[e("li",[n._v("有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）")]),n._v(" "),e("li",[n._v("无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）")])])]),n._v(" "),e("li",[n._v("复杂数据结构\n"),e("ul",[e("li",[n._v("树、堆")]),n._v(" "),e("li",[n._v("图")])])])]),n._v(" "),e("p",[n._v("对于简单数据结构，在 ES 中对应的是数组（Array）和对象（Object）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据key找到一个值是立即返回的，数组则需要查找的过程。")]),n._v(" "),e("p",[n._v("这里我通过一个真实面试题目来说明介绍下数据结构设计。")]),n._v(" "),e("blockquote",[e("p",[n._v("题目：使用 ECMAScript（JS）代码实现一个事件类Event，包含下面功能：绑定事件、解绑事件和派发事件。")])]),n._v(" "),e("p",[n._v("在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用「订阅发布模式」，即组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法，这就是题目要求写的Event类。")]),n._v(" "),e("p",[n._v("这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个_cache对象来记录绑定了哪些事件。而事件发生的时候，我们需要从_cache中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数们，然后执行。")]),n._v(" "),e("p",[n._v("经过这样一番考虑，我简单写了下代码实现：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Event {\n    constructor() {\n        // 存储事件的数据结构\n        // 为了查找迅速，使用了对象（字典）\n        this._cache = {};\n    }\n    // 绑定\n    on(type, callback) {\n        // 为了按类查找方便和节省空间，\n        // 将同一类型事件放到一个数组中\n        // 这里的数组是队列，遵循先进先出\n        // 即先绑定的事件先触发\n        let fns = (this._cache[type] = this._cache[type] || []);\n        if (fns.indexOf(callback) === -1) {\n            fns.push(callback);\n        }\n        return this;\n    }\n    // 触发\n    trigger(type, data) {\n        let fns = this._cache[type];\n        if (Array.isArray(fns)) {\n            fns.forEach((fn) => {\n                fn(data);\n            });\n        }\n        return this;\n    }\n    // 解绑\n    off(type, callback) {\n        let fns = this._cache[type];\n        if (Array.isArray(fns)) {\n            if (callback) {\n                let index = fns.indexOf(callback);\n                if (index !== -1) {\n                    fns.splice(index, 1);\n                }\n            } else {\n                //全部清空\n                fns.length = 0;\n            }\n        }\n        return this;\n    }\n}\n// 测试用例\nconst event = new Event();\nevent.on('test', (a) => {\n    console.log(a);\n});\nevent.trigger('test', 'hello world');\n\nevent.off('test');\nevent.trigger('test', 'hello world');\n")])])]),e("p",[n._v("类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇见的「查找最大的 K 个数」这类算法问题，就会迎刃而解。")]),n._v(" "),e("h2",{attrs:{id:"参考网址"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考网址","aria-hidden":"true"}},[n._v("#")]),n._v(" 参考网址")]),n._v(" "),e("p",[e("a",{attrs:{href:""}},[n._v("掘进小册")])])])},[],!1,null,null,null);t.default=s.exports}}]);