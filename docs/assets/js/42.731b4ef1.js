(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{305:function(t,a,v){"use strict";v.r(a);var _=v(38),r=Object(_.a)({},function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"作用域是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域是什么","aria-hidden":"true"}},[t._v("#")]),t._v(" 作用域是什么")]),t._v(" "),v("p",[t._v("作用域是一套规则。")]),t._v(" "),v("h2",{attrs:{id:"概要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概要","aria-hidden":"true"}},[t._v("#")]),t._v(" 概要")]),t._v(" "),v("ul",[v("li",[t._v("变量/状态")]),t._v(" "),v("li",[t._v("规则")]),t._v(" "),v("li",[t._v("编译原理")]),t._v(" "),v("li",[t._v("引擎")])]),t._v(" "),v("h3",{attrs:{id:"变量-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量-状态","aria-hidden":"true"}},[t._v("#")]),t._v(" 变量/状态")]),t._v(" "),v("blockquote",[v("p",[t._v("为何有变量这个概念")])]),t._v(" "),v("p",[t._v("变量：用来保存或者修改某一个引用。类比平常下载东西时的百分比，这个百分比好比是一个变量，如果没有变量存在的话，相当于每次下载都要从0开始。")]),t._v(" "),v("blockquote",[v("p",[t._v("为何说变量导致产生了状态？")])]),t._v(" "),v("p",[t._v("状态：还是拿下载东西来举例。只要当进度为100%，才表示下载完成，非100%的就认为是未完成，或者说是下载中。像这些 完成，下载中，未完成，其实就是下载的状态。而之所以可以有这个状态，是因为有一个下载进度这个变量，可以访问并且修改，所以才体现感知的。")]),t._v(" "),v("blockquote",[v("p",[t._v("为何说有变量能做做很多有意思的事情呢？")])]),t._v(" "),v("p",[t._v("拿2类计算器来举例。1个是简单的计算器，另外一个是带存储功能的科学计算器。")]),t._v(" "),v("p",[t._v("简单的计算器，只能进行1-9，+=*/ 四类操作运算。没进行1次计算，都需要从头开始。")]),t._v(" "),v("p",[t._v("科学计算器，除了简单计算器支持的功能外，还支持变量存储的功能，可以保存或者查看之前进行过的计算，如果有相同部分的运算，不用从头开始进行了。")]),t._v(" "),v("h3",{attrs:{id:"规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#规则","aria-hidden":"true"}},[t._v("#")]),t._v(" 规则")]),t._v(" "),v("blockquote",[v("p",[t._v("为什么说作用域是一套规则？")])]),t._v(" "),v("p",[t._v("作用域是一套规则，用来控制变量存在哪儿，如何访问的规则。至于为啥说为何只做规则，不做别的。首先，单从字面来理解，可以理解作用域为作用的范围，那针对于谁呢，肯定还是变量，如何确定这些变量能在哪儿访问的，具体变量的取值应该如何取的，于此推断，也能得出作用域其实是一套基于变量的规则。再者，从js分工来看。一共有3个。与作用域相关联的还有引擎，和编译器。引擎负责执行代码，而编译器负责将代码解析然后转译成浏览器可识别的代码。再具体深入些，引擎执行的是编译器编译后的代码，那这些代码涉及到的变量的访问或者修改，就需要有1个专门负责的，所以说也只有作用域去做了。")]),t._v(" "),v("p",[t._v("类比说明:引擎好比来拿文件的。具体文件在哪儿是作用域知道的。而这个文件来源于编译器编译之后。作用域之所以知道是因为编译器告诉的，只不过编译器只管生成，而作用域会决定放在何处，比如全局作用域，函数作用域，块级作用域等等。")]),t._v(" "),v("p",[t._v("作用域的本质主要是为引擎执行代码时服务，同时又对接接收编译器生成后的代码的。为前者服务时，引擎一般会有2个要求，1个是访问，1个是修改。对于访问来说，作用域首先会从当前开始找，找不到就会向上查找，直到全局作用域还没有，则会创建改变量，同时返回未定义。如果是修改，还是会先进行变量查找，从当前开始，逐级到顶层，如果没有找到变量的话，就会报错引用错误，否则进行赋值操作。")]),t._v(" "),v("h2",{attrs:{id:"编译原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 编译原理")]),t._v(" "),v("blockquote",[v("p",[t._v("为什么要有编译原理？")])]),t._v(" "),v("p",[t._v("因为浏览器无法直接识别js代码，需要js编译器转译之后才能识别，而这个编译的过程其实就是编译原理。大概分为以下3个步骤。")]),t._v(" "),v("ul",[v("li",[t._v("1.分词/词法解析:这一阶段，除 分词，词法解析这2个黑白道的老大外，还有个背后的终极老大-词法单元解析器。这个终极老大会根据js代码是否有状态，还是无状态，来决定交由哪个道儿上的老大去处理。至于有状态无状态的理解，就好比是否在道上混过，比如var是个关键词，那看 关键词 池子 是否有这个var，有就证明是道儿上的，可以按照 白道 处理(假设白道就是有状态的。)，这2个老大最终形成的结果是 拆分出 词法单元，并且数据结构为数组，也就是收归小弟。")]),t._v(" "),v("li",[t._v("2.构建抽象语法树:这一阶段，其实就是数据结构转换，由数组转换为树。这个树叫做抽象语法树。如果是变量的话，这个树的结构大致为 变量声明->标识符->语法表达式->值;如果是函数的话，这个树的结构大致为 函数声明->标识符->参数->函数体")]),t._v(" "),v("li",[t._v("3.代码生成:这一阶段就是将树生成为浏览器可识别的代码，供js引擎执行。")])]),t._v(" "),v("h2",{attrs:{id:"引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引擎","aria-hidden":"true"}},[t._v("#")]),t._v(" 引擎")]),t._v(" "),v("blockquote",[v("p",[t._v("为什么需要引擎？")])]),t._v(" "),v("p",[t._v("引擎是用来做代码执行的。js代码被编译器转换成浏览器可识别的代码后，需要执行设置好的任务，而引擎就是负责这部分工作的。引擎在实际执行的过程中，会对变量进行访问或者修改。而这时候对执行左引用和右引用，经常会和作用域打交道，因为变量的访问和修改，是有一套规则控制的。而制定这套规则的人，就是作用域。但是和作用域的交往之中，它会给我想要的变量，但是有时候应该消失的变量却没有消失(因为闭包的存在)，所以 内存这家伙老是找我事儿，说我让他泄漏了，但不是我的锅啊。我只是按部就班的执行的。")]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("p",[t._v("《你不知道的JavaScript[上卷]》")])])},[],!1,null,null,null);a.default=r.exports}}]);