# js运行机制

既然目前理解不了，就摘录自己认为重要的，不断思考理解做demo

## 1.Event Loop

->先这么理解:简单来说是一套机制，好比交警，指导交通来往通行。不太确切，有更好的再调整

### 1.1 代码示例1

> 1.1.1 观察代码的执行顺序

```javascript
console.log(1)
    
setTimeout(function(){
    console.log(2)
},0)

console.log(3)
```

### 1.2 关键字提取

> 同步任务，异步任务，主线程，event table


### 1.3 小结1:

>按照这种分类方式:JS的执行机制是  

* 首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table   
* 异步任务在event table中注册函数,当满足触发条件后,被推入event queue   
* 同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中  
 
### 1.4 代码示例2

```javascript
 setTimeout(function(){
     console.log('定时器开始啦')
 });
 
 new Promise(function(resolve){
     console.log('马上执行for循环啦');
     for(var i = 0; i < 10000; i++){
         i == 99 && resolve();
     }
 }).then(function(){
     console.log('执行then函数啦')
 });
 
 console.log('代码执行结束');
```

### 1.5 关键字提取

> 同步任务，异步任务，主线程，event table，先后顺序，宏任务，微任务，队列

### 1.6 宏任务，微任务

* macro-task(宏任务)：包括整体代码script，setTimeout，setInterval  
* micro-task(微任务)：Promise，process.nextTick  

### 1.7 小结2

>按照这种分类方式:JS的执行机制是

* 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里  
* 当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完  

### 1.8 再度分析

>尝试按照刚学的执行机制,去分析例2:

* 首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里
* 遇到 new Promise直接执行,打印"马上执行for循环啦"
* 遇到then方法,是微任务,将其放到微任务的【队列里】
* 打印 "代码执行结束"
* 本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印"执行then函数啦"
* 到此,本轮的event loop 全部完成。
* 下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印"定时器开始啦"

## 2.单线程

### 2.1 进程和线程傻傻分不清

进程是cpu资源分配的最小单位，进程可以包含多个线程。 浏览器就是多进程的，每打开的一个浏览器窗口就是一个进程。

线程是cpu调度的最小单位，同一进程下的各个线程之间共享程序的内存空间。

### 2.2 类比记忆

可以把进程看做一个仓库，线程是可以运输的货车，每个仓库有属于自己的多辆货车为仓库服务（运货），每个仓库可以同时由多辆车同时拉货，但是每辆车同一时间只能干一件事，就是运输本次的货物。这样就好理解了吧。

### 2.3 浏览器中的进程和线程

浏览器包括4个进程：

* 主进程（Browser进程），浏览器只有一个主进程，负责资源下载，界面展示等主要基础功能  
* GPU进程，负责3D图示绘制  
* 第三方插件进程，负责第三方插件处理  
* 渲染进程（Renderer进程），负责js执行，页面渲染等功能，也是本章重点内容  

渲染进程 主要包括
* GUI渲染线程、
* Js引擎线程、
* 事件循环线程、
* 定时器线程、
* http异步线程。

### 2.4 GUI线程

先看看浏览器得到一个网站资源后干了哪些事：

* 首先浏览器会解析html代码（实际上html代码本质是字符串）转化为浏览器认识的节点，生成DOM树，也就是DOM Tree
* 然后解析css，生成CSSOM（CSS规则树）
* 把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)

GUI就是来干这个事情的，如果修改了一些元素的颜色或者背景色，页面就会重绘（Repaint），如果修改元素的尺寸，页面就会回流（Reflow），当页面需要Repaing和Reflow时GUI多会执行，进行页面绘制。

这里提示一点：Reflow比Repaint的成本更高，在js性能优化中会将如何避免Reflow和Repaint

### 2.5 JS引擎线程

js引擎线程就是js内核，负责解析与执行js代码，也称为主线程。浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的。

需要注意的是，js引擎线程和GUI渲染线程同时只能有一个工作，js引擎线程会阻塞GUI渲染线程

```html
<html>
    <body>
        <div id="div1"> a </div>
        <script>
            document.getElementById('div1').innerHTML = 'b'
        </script>
        <div id='div2'> div2 </div>
    </body>
</html>
```

>tip:

    在浏览器渲染的时候遇到<script>标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况，这也是后面性能优化的点。

### 2.6 按照组成部分小结

>js运行过程：

* 执行一个宏任务（栈中没有就从事件队列中获取）
* 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
* 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
* 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
* 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

## 参考网址

[10分钟理解JS引擎的执行机制](https://segmentfault.com/a/1190000012806637)  
[Js基础知识（四） - js运行原理与机制](https://segmentfault.com/a/1190000013119813)



